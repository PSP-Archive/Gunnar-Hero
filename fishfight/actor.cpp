// Class automatically generated by Dev-C++ New Class wizard
#ifdef _PSP
#include<pspdebug.h>
#endif

#include <math.h>

#include "actor.h" // class's header file

#ifdef _PSP
#define printf pspDebugScreenPrintf
#endif

// class constructor
Actor::Actor()
{
	entity=0;
	health=100;
	angle=0;
	walkSpeed=55.0f;	// walk 35/sec, or run 35*1.5/sec.
	turnSpeed=M_PI;	// 2 seconds to turn completely.
	movementMode=WALK_IDLE;
	turnMode=0;
}

// class destructor
Actor::~Actor()
{
}

// returns the value of entity
MD3Entity * Actor::getEntity()
{
	return entity;
}

// sets the value of entity
void Actor::setEntity(MD3Entity * x)
{
	entity = x;
}

void Actor::setAnimation(int value,int now)
{
	if(value<=BOTH_DEAD3) {
		setTracker(upperTracker,value,now);
		setTracker(lowerTracker,value,now);
	} else if(value<=TORSO_STAND2) {
		// Upper body only
		// TORSO type actions can be queued.
		upperTracker.queued=value;
	} else if(value<=LEGS_TURN) {
		// Lower body only
		// LEGS type actions can be queued.
		//lowerTracker.queued=value;
		setTracker(lowerTracker,value,now);
	}
}

void Actor::setTracker(AnimationTracker &tracker,int value,int startTime)
{
	// BOTH type actions cannot be queued.
	tracker.startTime=startTime;
	//printf("setTracker: seting mode to %d\n",value);
	tracker.active=value;
	tracker.queued=value;
	tracker.rate=1000/entity->md3anim.anim[value].framesPerSecond;
	
	tracker.lastFrame=tracker.nextFrame;
	tracker.nextFrame=entity->md3anim.anim[value].firstFrame;
#if 0
{
	int i;
	for(i=0;i<BOTH_MAX;i++) {
		printf("setTracker: firstFrame[%d]=%d\n",i,md3anim.anim[i]);
	}
}	
	
	printf("setTracker: nextFrame=%d\n",tracker.nextFrame);
#endif	
	tracker.weight=0.0f;
}

void Actor::updateTracker(AnimationTracker &tracker,int elapsed)
{
	if(!entity) return;
	if(tracker.delay>10000) {
		tracker.delay=0;	// Hack, of course.  I'm to tired to fix.
		return;
	}
//printf("Tracker: active=%d, queued=%d\n",tracker.active,tracker.queued);
	if(elapsed<tracker.delay) {
		tracker.weight=(float)elapsed/(float)tracker.rate;
//printf("Elapsed: %d; Rate: %d; Delay: %d\n",elapsed,tracker.rate,tracker.delay);
//printf("Tracker frame static at %d\n",tracker.nextFrame);
		tracker.delay-=elapsed;
		tracker.startTime+=elapsed;
		return;
	}
	// Initial state
	if(tracker.nextFrame<entity->md3anim.anim[tracker.active].firstFrame) {	// New action ready to go
		setTracker(tracker,tracker.queued,tracker.startTime+elapsed);
//printf("Initial mode. Set tracker to %d\n",tracker.nextFrame);
		return;
	}
	// Now time to decide on a new frame.
	tracker.delay+=tracker.rate;
	tracker.lastFrame=tracker.nextFrame;	// Frame is changing
	tracker.startTime+=elapsed;
	if(tracker.nextFrame+1<entity->md3anim.anim[tracker.active].firstFrame+entity->md3anim.anim[tracker.active].numFrames) {
		tracker.nextFrame++;
//printf("Tracker frame incremented to %d\n",tracker.nextFrame);
		return;
	}
	// We are the the end of the sequence.  To loop or not to loop.
	if(tracker.queued!=tracker.active) {	// New action ready to go
		setTracker(tracker,tracker.queued,tracker.startTime+elapsed);
//printf("New mode. Set tracker to %d\n",tracker.nextFrame);
		return;
	}
	if(entity->md3anim.anim[tracker.active].loopingFrames==0) {
		tracker.weight=0.0f;
//printf("Tracker frame stuck at %d\n",tracker.nextFrame);
		return;	// Stuck on last frame
	}
	// We have a looping animation, so jump back to the beginning of the loop.
	tracker.nextFrame=entity->md3anim.anim[tracker.active].firstFrame+entity->md3anim.anim[tracker.active].numFrames-entity->md3anim.anim[tracker.active].loopingFrames;
//printf("Tracker looping to %d\n",tracker.nextFrame);
}

void Actor::updateAnimation(int now)
{
	// Update lower first
	int elapse;
	elapse=now-lowerTracker.startTime;
	// Time for next frame for lower.
	updateTracker(lowerTracker,elapse);
	elapse=now-upperTracker.startTime;
	updateTracker(upperTracker,elapse);
	
	// Now translate the character according to the angle and walking speed and elapsed time
	if(elapse>0 && elapse<1000) {	// We have a reasonable amount of elapsed time
		angle+=elapse/1000.0f*turnSpeed*turnMode;
		float magnitude=elapse/1000.0f*walkSpeed;
		float s=sinf(angle);
		float c=cosf(angle);
		if(movementMode==WALK_BK) magnitude=-magnitude;
		switch(movementMode) {
		case WALK_IDLE:
			break;	// Not moving
		case RUN_FD:
			magnitude*=1.5f;
			// fall through
		case WALK_FD:
		case WALK_BK:
			pos.m[12]+=s*magnitude;
			pos.m[13]+=c*magnitude;
			// fall through
		case WALK_TURN:
			break;
		}
		// Now set the actor transform matrix based on the angle variable.
		pos.m[0]=s;
		pos.m[1]=c;
		pos.m[4]=-c;
		pos.m[5]=s;
	}
}

Frame *Actor::getCurrLowerFrame()
{
	if(!entity) return 0;
	return entity->lowerFrame[lowerTracker.nextFrame];
}

Frame *Actor::getCurrUpperFrame()
{
	if(!entity) return 0;
	return entity->upperFrame[upperTracker.nextFrame];
}

float *Actor::getCurrLowerTransform()
{
	if(!entity) return 0;	
	return entity->lowerTransform[lowerTracker.nextFrame].m;
}

/*
 * @returns 4x4 matrix with the torso to weapon linkage.
 */
float * Actor::getCurrUpperTransform()
{
	if(!entity) return 0;
	return entity->upperTransform[upperTracker.nextFrame].m;
}

void Actor::setXYZ(float x,float y,float z)
{
	pos.m[12]=x;
	pos.m[13]=y;
	pos.m[14]=z;
}

float *Actor::getTransform()
{
	return pos.m;
}

/*
 * Get movement mode
 * 
 * @returns movement mode, like WALK_IDLE, WALK_FD, WALK_BK, etc.
 */
int Actor::getMovement()
{
	return movementMode;
}


// returns the value of attackMode
int Actor::getAttack()
{
	return attackMode;
}


// sets the value of attackMode
void Actor::setAttack(int x)
{
	attackMode = x;
}

// sets the value of attackMode
void Actor::setMovement(int x)
{
	movementMode = x;
}

/*
 * This retreives the textures used by the actor.
 * 
 * @returns TextureHolder that contains the list of textures.
 */
TextureHolder * Actor::getTextures()
{
	return entity;
}

void Actor::setTurn(int dir)
{
	turnMode=dir;
}
