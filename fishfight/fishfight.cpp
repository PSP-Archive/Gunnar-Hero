// Class automatically generated by Dev-C++ New Class wizard

#include "mesh.h"
#include "fishfight.h" // class's header file

// class constructor
FishFight::FishFight()
{
	score=0;
	hero=0;
	lastTick=0;
	modelShinobu=0;
	modelNarusegawa=0;
	sceneEntity=0;
}

// class destructor
FishFight::~FishFight()
{
	if(modelShinobu) delete modelShinobu;
	modelShinobu=0;
	if(modelNarusegawa) delete modelNarusegawa;
	modelNarusegawa=0;
	if(sceneEntity) delete sceneEntity;
	sceneEntity=0;
}

// returns the value of heroEntity
Actor * FishFight::getHero()
{
	return hero;
}

/*
 * Loads in the level specified, and initializes all things needed.
 * 
 * @level the level number to load (0 based)
 * @returns 0 on success, negative on error.
 */
int FishFight::load(int level)
{
	if(!modelShinobu) modelShinobu=load_animated_md3("models/players/shinobu/");
	if(!modelNarusegawa) modelNarusegawa=load_animated_md3("models/players/narusegawa/");
	if(!sceneEntity) sceneEntity=load_xof("map/market1.x");
	if(!hero) {
		hero=new Actor();
		hero->setEntity(modelShinobu);
	}
	hero->setAnimation(LEGS_IDLE,lastTick);
	hero->setAnimation(TORSO_STAND2,lastTick);
	if(npc.size()<1) {
		// Add in 3 bots:
		Actor *bot;
		int i;
		for(i=0;i<3;i++) {
			bot=new Actor();
			bot->setEntity(modelNarusegawa);
			// Translate to initial pos
			bot->pos.m[12]=i*20;
			bot->pos.m[13]=((i+2)%3)*10;
			bot->pos.m[14]=0;
			bot->setAnimation(TORSO_STAND2,lastTick);
			bot->setAnimation(LEGS_IDLE,lastTick);
			npc.push_back(bot);
		}
	}
	return 0;
}


// returns the value of sceneEntity
Entity * FishFight::getSceneEntity()
{
	return sceneEntity;
}


// returns the value of score
int FishFight::getScore()
{
	return score;
}


// returns the value of health
int FishFight::getHealth()
{
	return getHero()->health;
}

/*
 * New game is called to initialize the game engine.  It resets
 * the score, health, level, loads the initial level, and resets 
 * the NPCs.
 */
void FishFight::newGame()
{
	score=0;
	hero=0;
	lastTick=0;
	//load(1);
}

/*
 * Updates the state of all entities in the currently active level.
 * 
 * @param milliseconds milliseconds since the game/level/machine started.
 */
void FishFight::updateLevel(int milliseconds)
{
	if(hero) hero->updateAnimation(milliseconds);
	std::vector<Actor *>::iterator p;
	for(p=npc.begin();p!=npc.end();p++) {
		Actor *bot;
		bot=*p;
		bot->updateAnimation(milliseconds);
	}
	// now somehow the bots, and hero need to decide what motion and
	// other stuff needs to be done still.
	hero->updateAnimation(milliseconds);
	// I'll have to code the AI.
	// And also the other stuff.
	lastTick=milliseconds;
}

/*
 * Receives a button event.
 * 
 * @param id the button id of the button (0=triangle, etc).
 * @param down true if the button is pressed, and false if the button was released.
 */
void FishFight::buttonEvent(int id,int down,int milliseconds)
{
	int mask=0;
	int oldButtonState=buttonState;
	if(id<FF_MAX) {
		mask=1<<id;
		if(down) {		// Record list of button changes.
			buttonState |= mask;
		} else {
			mask ^= 0xffffffff;
			buttonState &= mask;
		}
	}
	if(down==0 && (id==FF_UP || id==FF_DOWN)) {	// May have stopped moving
		if((buttonState&((1<<FF_UP)|(1<<FF_DOWN)))==0) {
			hero->setAnimation(LEGS_IDLE,milliseconds);
			hero->setMovement(WALK_IDLE);
		} else {
			// Only headed in one direction now:
			if(id==FF_UP) { // Not up, so down
				hero->setAnimation(LEGS_BACK,milliseconds);
				hero->setMovement(WALK_BK);
			} else {
				hero->setAnimation(LEGS_WALK,milliseconds);
				hero->setMovement(WALK_FD);
			}
		}
	}
	if(down && id==FF_UP) {	// Walk forward
		hero->setAnimation(LEGS_WALK,milliseconds);
		hero->setMovement(WALK_FD);
	}
	if(down && id==FF_DOWN) {	// Walk back
		hero->setAnimation(LEGS_BACK,milliseconds);
		hero->setMovement(WALK_BK);
	}
	if(down && (id==FF_LEFT || id==FF_RIGHT) && hero->getMovement()==WALK_IDLE) {	// Start turn mode animation
		hero->setAnimation(LEGS_TURN,milliseconds);
		hero->setMovement(WALK_TURN);
		hero->setTurn(id==FF_LEFT?-1:1);
	}
	if(down==0 && (id==FF_LEFT || id==FF_RIGHT)) {
		hero->setTurn(0);
	}
	if(down && id==FF_CROSS && (oldButtonState&(1<<FF_CROSS))==0) {	// Attack.
		// Start a fresh new attack if appropriate.
		hero->setAnimation(TORSO_ATTACK2,milliseconds);
		hero->setAttack(1);
	}
	if(down==0 && id==FF_CROSS) {	// End attack
		hero->setAttack(0);
		hero->setAnimation(TORSO_STAND2,milliseconds);
	}
	if(down && id==FF_SQUARE) {	// Run.
		// Start a fresh new attack if appropriate.
		hero->setAnimation(LEGS_RUN,milliseconds);
	}
	if(down && id==FF_TRIANGLE) {	// Jump.
		// Start a fresh new attack if appropriate.
		hero->setAnimation(LEGS_JUMP,milliseconds);
	}
	if(down==0 && id==FF_TRIANGLE) {	// Jump.
		// Start a fresh new attack if appropriate.
		hero->setAnimation(LEGS_LAND,milliseconds);
	}
	if(id==FF_CIRCLE) {	// Gesture.
		// Start a fresh new attack if appropriate.
		hero->setAnimation(TORSO_GESTURE,milliseconds);
	}
	lastTick=milliseconds;
}

/*
 * A keyboard event was received.
 * 
 * @param ch ASCII character or special keycode.
 * @param down true if pressed, or false if released.
 */
void FishFight::keyEvent(int ch,int down)
{
	/* TODO (#1#): Implement FishFight::keyEvent() */
}
