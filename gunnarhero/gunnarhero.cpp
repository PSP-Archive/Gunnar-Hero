// Class automatically generated by Dev-C++ New Class wizard

#include <sys/types.h>
#include <math.h>
#include <dirent.h>
#include "tinyxml.h"
#include "mesh.h"
#include "piece.h"
#include "gunnarhero.h" // class's header file
#include "mp3player.h"

#ifdef DMALLOC
#include <dmalloc.h>
#endif

#define ABINF 84765625

void multTransform(float *t1,float *t2)
{
	int i,j,k;
	float r[16];
	for(i=0;i<16;i++) r[i]=0;
	for(i=0;i<4;i++) {
		for(j=0;j<4;j++) {
			for(k=0;k<4;k++) {
				r[i*4+j]+=t1[i*4+k]*t2[k*4+j];
			}
		}
	}
#if 0
	for(i=0;i<16;i+=4) {
		printf("[%.2f %.2f %.2f %.2f]x",t1[i+0],t1[i+1],t1[i+2],t1[i+3]);
		printf("[%.2f %.2f %.2f %.2f]=",t2[i+0],t2[i+1],t2[i+2],t2[i+3]);
		printf("[%.2f %.2f %.2f %.2f]\n",r[i+0],r[i+1],r[i+2],r[i+3]);
	}
	printf("\n");
#endif
	for(i=0;i<16;i++) t1[i]=r[i];
}

void rotateTransformXYZ(float *transform,float xrot,float yrot,float zrot)
{
	float t[16];
	int i;
	int from[]={1,0,0};
	int to[]={2,2,1};
	float angle[3];
	int dir;

	angle[0]=xrot;
	angle[1]=yrot;
	angle[2]=zrot;

	for(dir=0;dir<3;dir++) {
		for(i=0;i<16;i++) t[i]=(i%4)==i/4?1:0;
		float c=cosf(angle[dir]);
		float s=sinf(angle[dir]);
		t[from[dir]*4+from[dir]]=c;
		t[to[dir]*4+from[dir]]=-s;
		t[from[dir]*4+to[dir]]=s;
		t[to[dir]*4+to[dir]]=c;

		multTransform(transform,t);
	}
}

void scaleTransform(float *transform,float x,float y,float z)
{
	float t[16];
	int i;

	for(i=0;i<16;i++) t[i]=(i%4)==i/4?1:0;
	t[0]=x;
	t[5]=y;
	t[10]=z;
	multTransform(transform,t);
}

void translateTransform(float *transform,float x,float y,float z)
{
	float t[16];
	int i;

	for(i=0;i<16;i++) t[i]=(i%4)==i/4?1:0;
	t[12]=x;
	t[13]=y;
	t[14]=z;
	multTransform(transform,t);
}

// class constructor
GunnarHero::GunnarHero()
{
	int i;
	
	score=0;
	lastTick=0;
	modelBoard=0;
	modelGood=0;
	for(i=0;i<5;i++) {
		modelButton[i]=0;
		modelKeys[i]=0;
		openKeyImage[i]=0;
		closedKeyImage[i]=0;
		modelBar[i]=0;
	}
	modelGrid=0;
	modelRoom=0;
	themeNo=0;
	muteSfx=false;
	muteMusic=false;
	pauseMenu=false;
	setMode(GM_MODEMENU);
	songRequested=false;

	int map[]={
			KMAP_NONE,KMAP_GREEN,KMAP_BLUE,KMAP_RED,
			KMAP_NONE,KMAP_NONE,KMAP_NONE,KMAP_STRUM,
			KMAP_ORANGE,KMAP_YELLOW,
			KMAP_SCREENSHOT,KMAP_PAUSE,KMAP_NONE};
	for(i=0;i<FF_MAX;i++) {
		defaultKeymap[i]=map[i];
	}
	
	for(i=0;i<FF_MAX;i++) {
		keymap[i]=defaultKeymap[i];
	}
	menuMode.setDisplayable(this);
}

// class destructor
GunnarHero::~GunnarHero()
{
	std::deque<Piece *>::iterator p;
	for(p=piece.begin();p!=piece.end();p++) {
		Piece *pp=*p;
		delete pp;
	}
	piece.clear();
	int i;
	for(i=0;i<5;i++) {
		if(modelButton[i]) {
			modelButton[i]->swapTexture("button.png",0);
			delete modelButton[i];
			modelButton[i]=0;
		}
		if(modelKeys[i]) {
			modelKeys[i]->swapTexture("key.png",0);
			delete modelKeys[i];
			modelKeys[i]=0;
		}
		if(modelKeys[i]) {
			modelKeys[i]->swapTexture("bar.png",0);
			delete modelBar[i];
			modelBar[i]=0;
		}
		if(openKeyImage[i]) {
			delete openKeyImage[i];
			openKeyImage[i]=0;
		}
		if(closedKeyImage[i]) {
			delete closedKeyImage[i];
			closedKeyImage[i]=0;
		}
	}
	if(modelGood) free_entity(modelGood);
	modelGood=0;
	if(modelBoard) free_entity(modelBoard);
	modelBoard=0;
	if(modelGrid) free_entity(modelGrid);
	modelGrid=0;
	if(modelRoom) free_entity(modelRoom);
	modelRoom=0;
}

void GunnarHero::switchTheme()
{
    Piece *pp=0; 
	if(theme.size()<1) return;
	if(modelRoom) free_entity(modelRoom);

	std::deque<Piece *>::iterator p;
	for(p=piece.begin();p!=piece.end();p++) {
		pp=*p;
		if(pp->type==PT_ROOM) break;
	}
	if(pp && pp->type!=PT_ROOM) pp=0;

	themeNo++;
	if(themeNo>=theme.size()) themeNo=0;
	modelRoom=load_xof(theme[themeNo].c_str());
	if(pp) pp->setModel(modelRoom,PT_ROOM);
}

void GunnarHero::orientPiece(Entity *modelPiece)
{
	if(modelPiece) {
		std::vector<Frame *>::iterator p;
		for(p=modelPiece->frame.begin();p!=modelPiece->frame.end();p++) {
			Frame *f;
			f=*p;
			float *t=f->transform;
			translateTransform(t,-t[12],-t[13],-t[14]);
			rotateTransformXYZ(t,-M_PI/2,M_PI/2,0);
		}
	}
}

/*
 * Loads in the level specified, and initializes all things needed.
 * 
 * @level the level number to load (0 based)
 * @returns 0 on success, negative on error.
 */
int GunnarHero::load(int level)
{
	// Try to read in the keymap
	FILE *file=fopen("data/kmap","rb");
	if(file) {
		fread(keymap,FF_MAX,sizeof(int),file);
		fclose(file);
	}
	int i;
	for(i=0;i<FF_MAX;i++) {
		if(keymap[i]<0 || keymap[i]>=FF_MAX) {
			for(i=0;i<FF_MAX;i++) {
				keymap[i]=defaultKeymap[i];
			}
			FILE *file=fopen("data/kmap","wb");
			if(file) {
				fwrite(keymap,FF_MAX,sizeof(int),file);
				fclose(file);
			}
		}
	}
	static bool mp3initneeded=true;
	if(mp3initneeded) {
		mp3initneeded=false;
		MP3_Init(1);
		printf("Initialized MP3\n");
	}
	if(!modelRoom) {
		modelRoom=load_xof("data/stage.x");
		//orientPiece(modelRoom);
	}
	if(!modelBoard) {
		modelBoard=load_xof("data/band.x");
		//orientPiece(modelBoard);
	}
	if(!modelGrid) {
		modelGrid=load_xof("data/plane.x");
		orientPiece(modelGrid);
	}
	if(!modelGood) {
		modelGood=load_xof("data/button.x");
		orientPiece(modelGood);
		Image *old=0,*image=loadImage("data/buttongood.png");
		if(image) {
			old=modelGood->swapTexture("button.png",image);
			//printf("*>New image %dx%d\n>Old image %dx%d\n",image->textureWidth,image->textureHeight,old->textureWidth,old->textureHeight);
			if(old) delete old;
		}
	}
	if(!modelButton[0]) {
		int i;
		for(i=0;i<5;i++) {
			modelButton[i]=load_xof("data/button.x");
			orientPiece(modelButton[i]);
			char buf[64];
			sprintf(buf,"data/button%d.png",i);
			Image *old=0,*image=loadImage(buf);
			if(image) {
				old=modelButton[i]->swapTexture("button.png",image);
				//printf("*>New image %dx%d\n>Old image %dx%d\n",image->textureWidth,image->textureHeight,old->textureWidth,old->textureHeight);
				if(old) delete old;
			}
		}
	}
	if(!modelKeys[0]) {
		int i;
		for(i=0;i<5;i++) {
			modelKeys[i]=load_xof("data/key.x");
			//orientPiece(modelKeys[i]);
			char buf[64];
			sprintf(buf,"data/keyopen%d.png",i);
			Image *old=0,*image=loadImage(buf);
			openKeyImage[i]=image;
			sprintf(buf,"data/keyclosed%d.png",i);
			closedKeyImage[i]=loadImage(buf);
			printf("Keyopen: %08x  Keyclosed: %08x\n",image,closedKeyImage[i]);
			if(image) {
				printf("Replacing key.png with %08x\n",image);
				old=modelKeys[i]->swapTexture("key.png",image);
				if(old) delete old;
			}
		}
	}
	if(!modelBar[0]) {
		int i;
		for(i=0;i<5;i++) {
			modelBar[i]=load_xof("data/bar.x");
			//orientPiece(modelBar[i]);
			char buf[64];
			sprintf(buf,"data/bar%d.png",i);
			Image *old=0,*image=loadImage(buf);
			if(image) {
				old=modelButton[i]->swapTexture("bar.png",image);
				//printf("*>New image %dx%d\n>Old image %dx%d\n",image->textureWidth,image->textureHeight,old->textureWidth,old->textureHeight);
				if(old) delete old;
			}
		}
	}
	
	if(!blue10.texture) {
		// Try to load in the fonts.
		blue10.load("data/ArialBlue_10.fnt");
		blue16.load("data/ArialBlue_16.fnt");
		gray10.load("data/ArialGray_10.fnt");
		gray16.load("data/ArialGray_16.fnt");
	}
	//if(!sceneEntity) sceneEntity=load_xof("map/market1.x");
	std::deque<Piece *>::iterator p;
	for(p=piece.begin();p!=piece.end();p++) {
		Piece *pp=*p;
		delete pp;
	}
	piece.clear();
	
	//Piece *pp;
	if(modelRoom) {
		Piece *pp=new Piece();
		pp->setModel(modelRoom,PT_ROOM);
		piece.push_back(pp);
#if 1
		//scaleTransform(pp->getTransform(),4.0f,4.0f,4.0f);
		rotateTransformXYZ(pp->getTransform(),-M_PI/2,M_PI/2,0);
		//rotateTransformXYZ(pp->getTransform(),0,M_PI,0);
		//translateTransform(pp->getTransform(),40,-23,-50);
#endif
		printf("->-> added room model\n");
	} else {
		printf("->-> couldn't find room model\n");
	}
	if(modelBoard) {
#if 1
		SpritePiece *pp=new SpritePiece();
		pp->setModel(modelBoard,PT_BOARD);
		piece.push_back(pp);

		// Load the gunnar anim frames.
		Image *img;
		img=loadImage("data/ani1.png");
		if(img) pp->animFrames.push_back(img);
		img=loadImage("data/ani2.png");
		if(img) pp->animFrames.push_back(img);
		pp->animFilename="ani1.png";
		//scaleTransform(pp->getTransform(),5.0f,5.0f,5.0f);
		//rotateTransformXYZ(pp->getTransform(),-M_PI/2,M_PI/2,0);
		rotateTransformXYZ(pp->getTransform(),-M_PI/2,M_PI/2,0);
		//rotateTransformXYZ(pp->getTransform(),0,-M_PI/2,0);
		//translateTransform(pp->getTransform(),0,0,20);
		//scaleTransform(pp->getTransform(),1.0f,1.0f,1.0f);
#endif
	}

	DIR *dir=opendir("song");
	struct dirent *ent;
	while(dir && (ent=readdir(dir))) {
		if(strstr(ent->d_name,".sng")) {
			Song *song=new Song();
			char fname[256];
			sprintf(fname,"song/%s",ent->d_name);
			song->parsexml(fname);
			songLibrary.push_back(song);
			activeSong=song;
			songP=songLibrary.end();
			songP--;
		}
	}
	if(dir) closedir(dir);

	// Not the right spot
	//mode=GM_PVSP;
	//mode=GM_PVSAI;
	
	if(theme.size()<1) {
        FILE *file=fopen("themes.txt","r");
        if(file) {
            char line[256];
            while( fgets(line,255,file)) {
                line[255]=0;
                char *s=line;
                while(s[0]==' ') s++;	// Remove leading spaces
                if(strchr(s,'\n')) strchr(s,'\n')[0]=0;	// Remove trailing CR/LF
                if(strchr(s,'\r')) strchr(s,'\r')[0]=0;	// Remove trailing CR/LF
                if(strlen(s)>3) {
                    theme.push_back((std::string)s);
                }
            }
            fclose(file);
        }
    }

	// Needs to be done once, if we kept better track
	cameraStage.loadCameraPath("data/stage1.ASE",true);
	cameraBoard.loadCameraPath("data/board.ASE");

	playSound(S_LEVELSTART);

	setMode(GM_TITLE);
//	menuMode.setMenuModeType(MMT_MAIN);
//	menuMode.activate(true);
	return 0;
}


// returns the value of score
int GunnarHero::getScore()
{
	return score;
}

int GunnarHero::getHighScore()
{
	return highscore;
}

/*
 * New game is called to initialize the game engine.  It resets
 * the score, health, level, loads the initial level, and resets 
 * the NPCs.
 */
void GunnarHero::newGame()
{
	score=0;
	lastTick=0;
	//load(1);
}

/*
 * Updates the state of all entities in the currently active level.
 * 
 * @param milliseconds milliseconds since the game/level/machine started.
 */
void GunnarHero::updateLevel(unsigned long milliseconds)
{
	std::deque<Piece *>::iterator p;
	if(lastTick==0) lastTick=milliseconds-1;
	int i=0;
	char buf[64];

	if(mode==GM_MODEMENU) {
		if(menuMode.getMenuModeType()==MMT_NONE) {
//			menuMode.setMenuModeType(MMT_MAIN);
		}	
		menuMode.update(milliseconds);
		if(pauseMenu) {
			lastTick=milliseconds;
			return;	// Freeze the clock.
		}
	}
		
	sprintf(buf,"%06d",getScore());
	msgScore.message=buf;
	MP3_GetTimeString(buf);
	msgMp3Time.message=buf+1;
	
	cameraStage.update(milliseconds-lastTick);
	if(mode==GM_TITLE) {
		if(!cameraStage.cameraActive()) {
			setMode(GM_MODEMENU);
			menuMode.setMenuModeType(MMT_MAIN);
			return;
		}
	} else if(!cameraStage.cameraActive()) {
		// pick a new camera mode
		static int campath=0;
		static char *camfname[]={"data/camleft.ase","data/stage1.ase",
		"data/cammid.ase","data/cam2.ase","data/camright.ase"};
		cameraStage.loadCameraPath(camfname[campath++],true);
		if(campath>4) campath=0;
		cameraStage.doPath();
	}
	cameraBoard.update(milliseconds-lastTick);
	bool songActive=false;
	for(p=piece.begin();p!=piece.end();p++,i++) {
		Piece *bot;
		if(p==piece.end()) break;
		bot=*p;
		//printf("Calling update.\n");
		bot->update(milliseconds-lastTick);
		if(bot->type==PT_KEY && bot->action==PA_NONE && songRequested) {
			songRequested=false;
			int status=MP3_Play();
			printf("Playing MP3 (%d)\n",status);
		}
		if(bot->isButton()|| bot->isBar() ||bot->type==PT_GRID) songActive=true;
		while((bot->isButton()|| bot->isBar() ||bot->type==PT_GRID) && bot->action==PA_NONE) {
			// We need to delete it, if it stopped moving.
#if 0
			if(bot->type==PT_GRID) {
				char timelabel[64];
				MP3_GetTimeString(timelabel);
				//printf("MP3 status: %s\n",timelabel);
			}
#endif			
			delete bot;
			std::deque<Piece *>::iterator pt=piece.begin();
			piece.erase(p);	
			p=pt;
			if(p==piece.end()) break;
			bot=*p;
			bot->update(milliseconds-lastTick);
		}
		if(p==piece.end()) break;
	}
	// Here is where the game ai goes.
	if(mode==GM_PLAYING && songActive==false && songRequested==false) {
		setMode(GM_MODEMENU);
		menuMode.setMenuModeType(MMT_SUMMARY);
		menuMode.activate(true);
		MP3_Stop();
		MP3_FreeTune();
	}

	// Over.
	lastTick=milliseconds;
}

/*
 * Receives a button event.
 * 
 * @param id the button id of the button (0=triangle, etc).
 * @param down true if the button is pressed, and false if the button was released.
 */
void GunnarHero::buttonEvent(int id,int down,int milliseconds)
{
	int action=keymap[id];
	if(action==KMAP_SCREENSHOT && down==0) {
		// Screen shot.
		static int shotNo=0;
		char fname[256];
		shotNo++;
		sprintf(fname,"ghero-%02d.png",shotNo);
		saveScreenshot(fname);		
	}

	if(mode==GM_TITLE) {
		setMode(GM_MODEMENU);
		menuMode.setMenuModeType(MMT_MAIN);
		return;
	}

	if(mode==GM_MODEMENU) {
		if(pauseMenu==false && menuMode.getMenuModeType()==MMT_NONE) {
			menuMode.setMenuModeType(MMT_MAIN);
		}
		menuMode.buttonEvent(id,down,milliseconds);
		return;
	}
	if(down==0 && action==KMAP_PAUSE) {
		setPauseMode(true);
		setMode(GM_MODEMENU);
		menuMode.setMenuModeType(MMT_PAUSE);
		return;
	}

	// if(id==FF_UP && down==1) { cameraStage.doPath(); printf("Starting path over\n"); }
	// Now handle the game keys.  Should do some indirection to allow for alternate keymaps.  But I'm anxious ;-)
	int chd=-1;
	switch(action) {
	case KMAP_ORANGE: chd=0; break;
	case KMAP_GREEN: chd=1; break;
	case KMAP_RED: chd=2; break;
	case KMAP_BLUE:chd=3;	break;
	case KMAP_YELLOW: chd=4; break;
	case KMAP_STRUM:
		strum(down);
		return;
	default:
		return;
	}
	chord[chd]=down!=0;
	// Animate the key hole.
	modelKeys[chd]->swapTexture("key.png",down?closedKeyImage[chd]:openKeyImage[chd]);
}

/*
 * A keyboard event was received.
 * 
 * @param ch ASCII character or special keycode.
 * @param down true if pressed, or false if released.
 */
void GunnarHero::keyEvent(int ch,int down)
{
	/* TODO (#1#): Implement GunnarHero::keyEvent() */
}

void GunnarHero::calcPiecePos(float column,int row,float &x,float &y,float &z)
{
	y=-4.0f;
	z=120-row*30.0f;
	x=225.0f+column*120.0f;
	//printf("Row: %d, Column %d => %.2f,%.2f,%.2f\n",row,column,x,y,z);
}

/*
 * Adds Pieces to the scene description to animate the whole song with a 5 second lead in.
 * Removes any current Pieces of the type PT_BUTTON or PT_GRID.
 */
void GunnarHero::animateSong()
{
	Piece *pp;
	unsigned int i;
	std::deque<Piece *>::iterator p,pnext;
	std::vector<RiffBeat>::iterator q;

	setOverlays();
	
	i=0;
	// Clean out any left overs
	for(p=piece.begin();p!=piece.end();p++,i++) {
		pp=*p;
		while(pp && (pp->type==PT_GRID || pp->type==PT_KEY || pp->isButton() )) {
			delete pp;
			std::deque<Piece *>::iterator pt;
			pt=p+1;
			piece.erase(p);
			if(piece.size()<i) break;
			p=pt;
		}
	}
	if(!activeSong) return;
	std::string path="song/";
	path+=activeSong->musicFilename;
	int status=MP3_Load((char *)path.c_str());
	if(!pp) {
		menuMode.error1="Error loading MP3 ";
		menuMode.error2=path;
		char buf[64];
		sprintf(buf,"(code %d):",status);
		menuMode.error1+=buf;
		printf("%s %s\n",menuMode.error1.c_str(),menuMode.error2.c_str());
		setMode(GM_MODEMENU);
		menuMode.setMenuModeType(MMT_ERROR);
		return;
	}
	char timelabel[64];
	MP3_GetTimeString(timelabel);
	printf("Loaded MP3: %s (%d) :: %s\n",path.c_str(),status,timelabel);
	const float leadin=5.0;
	float min=-1,max=-1;	
	// Move the key indicators into place at the end of the leadin delay.
	for(i=0;i<5;i++) {
		float x,y,z;
		pp=new Piece();
		if(!pp) {
			menuMode.error1="Out of memory at";
			menuMode.error2="animateSong()::new Piece() +1";
			printf("%s %s\n",menuMode.error1.c_str(),menuMode.error2.c_str());
			setMode(GM_MODEMENU);
			menuMode.setMenuModeType(MMT_ERROR);
			return;
		}
		pp->setModel(modelKeys[i],PT_KEY);
		Image *old=modelKeys[i]->swapTexture("key.png",openKeyImage[i]);
		pp->transparent=true;
		piece.push_back(pp);
	
		calcPiecePos(4,i,x,y,z);
		pp->setPos(x,y+2,z);
		calcPiecePos(0,i,x,y,z);
		pp->setMoveTo(x,y+2,z,leadin);
	}
	for(q=activeSong->riffs.begin();q!=activeSong->riffs.end();q++) {
		const enum PieceType buttontype[]={
			PT_BUTTONORANGE,PT_BUTTONGREEN,PT_BUTTONRED,
			PT_BUTTONBLUE,PT_BUTTONYELLOW };
		const enum PieceType bartype[]={
			PT_BARORANGE,PT_BARGREEN,PT_BARRED,
			PT_BARBLUE,PT_BARYELLOW };
		RiffBeat riff=*q;
		if(riff.column<0 || riff.column>4) continue;
		float x,y,z;
		// place the button.
		pp=new Piece();
		if(!pp) {
			piece.erase(piece.begin(),piece.end());
			menuMode.error1="Out of memory at";
			menuMode.error2="animateSong()::new Piece() +2";
			printf("%s %s\n",menuMode.error1.c_str(),menuMode.error2.c_str());
			setMode(GM_MODEMENU);
			menuMode.setMenuModeType(MMT_ERROR);
			return;
		}
		pp->setModel(modelButton[riff.column],buttontype[riff.column]);
		piece.push_back(pp);

		calcPiecePos((-riff.time-leadin),riff.column,x,y,z);
		pp->setPos(x,y,z);
		calcPiecePos(activeSong->allowableErrorTime/2.0f,riff.column,x,y,z);
		pp->setMoveTo(x,y,z,leadin+riff.time+activeSong->allowableErrorTime/2.0f);
		// place the bar if needed
		if(riff.duration>0.1f) {
			pp=new Piece();
			if(!pp) {
				piece.erase(piece.begin(),piece.end());
				menuMode.error1="Out of memory at";
				menuMode.error2="animateSong()::new Piece() +3";
				printf("%s %s\n",menuMode.error1.c_str(),menuMode.error2.c_str());
				setMode(GM_MODEMENU);
				menuMode.setMenuModeType(MMT_ERROR);
				return;
			}
			pp->setModel(modelBar[riff.column],bartype[riff.column]);
			piece.push_back(pp);

			// Should be a for loop, for all of the sustain sections.	
			calcPiecePos((-riff.time-leadin-riff.duration/2),riff.column,x,y,z);
			pp->setPos(x,y,z);
			calcPiecePos(activeSong->allowableErrorTime/2.0f,riff.column,x,y,z);
			pp->setMoveTo(x,y,z,leadin+riff.time+riff.duration/2+activeSong->allowableErrorTime/2.0f);
			//scaleTransform(pp->getTransform(),riff.duration,1,1);
		}
		min=leadin;
		if(max<leadin+riff.time || max==-1) max=leadin+riff.time;
	}
	// Make a plane that goes under the buttons.
#if 1
	float pos;
	for(pos=0.0f;pos<leadin+activeSong->length;pos+=2.2f) {
		float x,y,z;
		pp=new Piece();
		if(!pp) {
			piece.erase(piece.begin(),piece.end());
			menuMode.error1="Out of memory at";
			menuMode.error2="animateSong()::new Piece() +4";
			printf("%s %s\n",menuMode.error1.c_str(),menuMode.error2.c_str());
			setMode(GM_MODEMENU);
			menuMode.setMenuModeType(MMT_ERROR);
			return;
		}
		pp->setModel(modelGrid,PT_GRID);
		piece.push_back(pp);
	
		calcPiecePos(-leadin-pos+0.5f,2,x,y,z);
		pp->setPos(x,y-2,z);
		calcPiecePos(5,2,x,y,z);
		pp->setMoveTo(x,y-2,z,leadin+pos+5);
	}
#endif
	songRequested=true;
}

/*
 * Strum the chord.  Apply points, or play an screech, depending.
 * 
 * \param down strum direction.
 */
void GunnarHero::strum(bool down)
{
	int multiplier=1;
	int hits=0;
	int misses=0;

	// See if we are on target for the songs and burst the matches.
	if(!activeSong) return;
	std::deque<Piece *>::iterator p;
	for(p=piece.begin();p!=piece.end();p++) {
		Piece *pp=*p;
		if(pp->isButton() && pp->getMoveToTimeLeft()/1000.0f<activeSong->allowableErrorTime) {
			if(chord[typeToChord(pp->type)]==0) {
				misses++;
			} else {
				// We scored some points.
				hits+=25*multiplier;
				// Now transform it into a sparkle, based on the magnitude.
				pp->setModel(modelGood,PT_GRID);
			}
		}
	}
	// Now add points
	score+=hits;
}

/*
 * Converts from an enum to a chord column.
 * 
 * \param type the type of the piece to decode.
 * \returns the column number.
 */
int GunnarHero::typeToChord(enum PieceType type)
{
	switch(type) {
	//case PT_BUTTONORANGE: return 0;
	default: return 0;
	case PT_BUTTONGREEN: return 1;
	case PT_BUTTONRED: return 2;
	case PT_BUTTONBLUE: return 3;
	case PT_BUTTONYELLOW: return 4;
	}
	return 0;
}

int GunnarHero::getChord(int i)
{
	if(i<0 || i>4) return 0;
	return chord[i];
}

/*
 * erases all of the overlays currently loaded.
 * Note: it does not erase the images that they refer to.  
 * Those need to be managed seperately.
 */
void GunnarHero::eraseOverlay()
{
	std::deque<Overlay *>::iterator p;
	for(p=overlay.begin();p!=overlay.end();p=overlay.begin()) {
		Overlay *over=*p;
//		delete over;
		overlay.erase(p);
	}
	std::deque<Message *>::iterator q;
	for(q=message.begin();q!=message.end();q=message.begin()) {
		Message *msg=*q;
//		delete msg;
		message.erase(q);
	}
}

/*
 * Sets the game mode of the game music.  Pausing and unpausing the music as appropriates.
 * 
 * \param mode the new mode to set.  May have side effects 
 * such as pausing and unpausing the game play.
 */
void GunnarHero::setMode(enum GameMode gameMode)
{
	if(mode==GM_MODEMENU && gameMode==GM_PLAYING) {
		if(pauseMenu==false) {
			animateSong();
		}
	}
	mode=gameMode;
	if(mode==GM_MODEMENU) {
//		menuMode.activate(true);
	}
	if(pauseMenu && mode==GM_PLAYING) {
		setPauseMode(false);
	}
	if(gameMode==GM_MODEMENU && pauseMenu==false) {
		MP3_Stop();
	}
}

/*
 * Saves the high score in the high score list.
 * 
 * \param username
 */
void GunnarHero::saveHighScore(const char *username)
{
	/* TODO (#1#): Implement GunnarHero::saveHighScore() */
}

/*
 * Sets the pause mode.  Stops the animation, and pauses any music.
 * 
 * \param isPaused whether the mode should now be paused
 */
void GunnarHero::setPauseMode(bool isPaused)
{
	pauseMenu=isPaused;
	MP3_Pause(isPaused);
	setOverlays();
}

/*
 * Figures out the next song number, and points to it.
 */
void GunnarHero::nextSong()
{
	songP++;
	if(songP==songLibrary.end()) {
		songP=songLibrary.begin();
	}
	activeSong=*songP;
}

/*
 * Returns the active song
 * 
 * \returns the active song.
 */
Song * GunnarHero::getActiveSong()
{
	return activeSong;
}

/*
 * Sets up the overlays for the game HUD.
 * Used to recover from pause mode, and for intial setup.
 */
void GunnarHero::setOverlays()
{
	// Set up the overlays.
	overlay.erase(overlay.begin(),overlay.end());
	if(!jukeboxOverlay.image) jukeboxOverlay.image=loadImage("data/jukebox.png");
	jukeboxOverlay.x=360;
	jukeboxOverlay.y=0;
	overlay.push_back(&jukeboxOverlay);
	message.erase(message.begin(),message.end());
	msgMp3Time.set(&gray16,390,70,"00:00:00");
	message.push_back(&msgMp3Time);
	msgScore.set(&gray16,390,95,"0000");
	message.push_back(&msgScore);
	msgMult.set(&blue10,413,134,"x1");
	message.push_back(&msgMult);
}
